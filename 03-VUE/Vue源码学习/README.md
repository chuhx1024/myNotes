# VUE 源码解读

## 写在前面

- 要看一个项目的源码 不要 一上来就看 先去了解一下项目本身的元数据和依赖 特别是前端的开源项目 一个要看的就是 package.json 文件 了解了以后 如果有依赖 npm install 就 ok

## 一些概念

### VUE 2.0 和 3.0的区别
- 核心思想没有变化(响应式原理 设计思想) 主要是一些js的高级语法 让一些写法更加简洁 但本质是相同的

### 项目目录结构(大佬们都说VUE的结构很漂亮)
 ```
├── build --------------------------------- 构建相关的文件，一般情况下我们不需要动
├── dist ---------------------------------- 构建后文件的输出目录
├── examples ------------------------------ 存放一些使用Vue开发的应用案例
├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)
├── package.json -------------------------- 不解释
├── test ---------------------------------- 包含所有测试文件
├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码
│   ├── entries --------------------------- 包含了不同的构建或包的入口文件
│   │   ├── web-runtime.js ---------------- 运行时构建的入口，输出 dist/vue.common.js 文件，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意
│   │   ├── web-runtime-with-compiler.js -- 独立构建版本的入口，输出 dist/vue.js，它包含模板(template)到render函数的编译器
│   │   ├── web-compiler.js --------------- vue-template-compiler 包的入口文件
│   │   ├── web-server-renderer.js -------- vue-server-renderer 包的入口文件
│   ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数
│   │   ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码
│   │   ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码
│   │   ├── optimizer.js ------------------ 分析静态树，优化vdom渲染
│   ├── core ------------------------------ 存放通用的，平台无关的代码
│   │   ├── observer ---------------------- 反应系统，包含数据观测的核心代码
│   │   ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码
│   │   ├── instance ---------------------- 包含Vue构造函数设计相关的代码
│   │   ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码
│   │   ├── components -------------------- 包含抽象出来的通用组件
│   ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码
│   ├── platforms ------------------------- 包含平台特有的相关代码
│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包
│   ├── shared ---------------------------- 包含整个代码库通用的代码
 ```

 ### 关于虚拟DOM

- 简单理解: VUE 中数据状态的改变后会采用 virtual DOM 的方式更新 DOM 简单分为三个步骤
1. createElement(): 用 JavaScript对象(虚拟树) 描述 真实DOM对象(真实树)
2. diff(oldNode, newNode) : 对比新旧两个虚拟树的区别，收集差异
3. patch() : 将差异应用到真实DOM树
- 目的
1. 提升性能(频繁的操作dom浪费性能 先统一在内存处理虚拟dom 最后统一更新)

- 真实DOM => virtual DOM 
```
<div title="1" class="c">
    你好
    <p></p>
</div>
==> 
{ tag: 'div',
  data: {
    titel: '1',
    class: 'c',
  }, 
  value: '你好',
  children: [ // 数组可以是多个
    {tag: 'p'}
  ]
}
```
- 相互转换
    -  思想和深拷贝类似 深度遍历(递归 while循环) 
    - 递归遍历DOM 生成 virtaul DOM 
    - 递归遍历 virtaul DOM 生成 DOM
    - Vue 的源码中使用的是 栈结构 使用栈存储父元素来实现递归生成 这个操作功能和递归完全一样 
        - Vue 为什么这样用:
        1. 是 vue 解析的是字符串 
        2. vue 中 是把 dom 转换成字符串 
        3. 利用语法解析  解析成抽象语法树 然后在生成 virtaul DOM 

### 函数柯里化
- 定义
    - 柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。
- 目的
    缓存一些内容 减少解析
- 实用性体现
    - 提高适用性 (减少反复的相同传参: 模板固定 数据经常改变)
    - 延迟执行 (不断的柯里化，累积传入的参数，最后执行)
    - 固定易变因素(我们经常使用的函数的bind方法就是一个固定易变因素的很好的例子)
- 性能
    - 实用柯里化意味着一些额外的开销(函数参数的调用, 产生大量的闭包) 但是 web 应用的性能瓶颈主要在操作DOM上 所以.....
- 拓展概念
    1. 科里化: 一个函数原本有多个参数, 之传入**一个**参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构.
    2. 偏函数: 一个函数原本有多个参数, 之传入**一部分**参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结构.
    3. 高阶函数: 一个函数**参数是一个函数**, 该函数对参数这个函数进行加工, 得到一个函数, 这个加工用的函数就是高阶函数.



### Vue 的使用步骤

- 编写页面模板
    - 直接在HTMl标签中写标签
    - 使用 template
    - 使用单文件
- 创建 Vue 的实例
    - 在 vue 的构造函数中提供了 data methods computed watcher props ...
- 讲 Vue 挂载到 页面上

### 数据驱动模型

- Vue 的执行流程
    - 获得模板 模板中有坑
    - 利用Vue 构造函数中提供的数据来填坑 
- Vue 所做的事情 就是 利用我们提供的数据 和 页面中提供的模板 生成了几个新的 node元素 替换了页面中放置模板的位置



## 参考
+ [Vue2.1.7源码学习](http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/)
+ [前端基础进阶系列](https://www.jianshu.com/p/cd3fee40ef59)
+ [函数式编程](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)






