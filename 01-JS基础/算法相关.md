# 算法

## 基础概念

### 复杂度
- 时间复杂度
    - 运行一个算法需要多长时间 它和执行每条语句的耗时以及每条语句的执行频率有关 大O表示法 表示时间复杂度
- 空间复杂度
    - 万物都有容量，而应用程序的容器就是内存，内存暂用率越高，程序越容易崩溃。
### 常用的复杂度级别
- 多项式阶:
    - 随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长，包括，O(1)(常数阶)、O(logn)(对数阶)、O(n)(线性阶)、O(nlogn)(线性对数阶)、O(n^2)(平方阶)、O(n^3)(立方阶)。
- 非多项式阶:
    - 随着数据规模的增长，算法的执行时间和空间占用暴增，这列算法性能极差。包括，O(2^n)(指数阶)、O(n!)(阶乘阶)。
### 复杂度分析的四个概念
- 最坏情况时间复杂度：代码在最坏情况下执行的时间复杂度。
- 最好情况时间复杂度：代码在最理想情况下执行的时间复杂度。
- 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。
- 均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。
> 一般情况下，我们看一个算法的好坏，是看平均复杂度和最坏复杂度。一个算法在最坏的时间复杂度里也能有很好的性能，也代表了这个算法的可靠程度。

### 案例
1. 如何在数组的中间添加数组
```js
function avaerageAdd() {
    let nums = [1, 2, 3, 4, 5, 6, 7, 8]
    const newArr = [233, 666]
    nums.splice.apply(nums, [Math.floor(nums.length/2), 0].concat(newArr))
    return nums
}
// [1, 2, 3, 4, 233, 666, 5, 6, 7, 8]
```
2. 判断给定字符串是否回文 (以某个字符为中心的前缀和后缀都是相同的) '1234321' 'abcbc'
```js
function isPlalindrome (word) {
    let s = []
    Array.prototype.forEach.call(word, item => {
        s.push(item)
    })
    let rword = ''
    while(s.length > 0) {
        rword += s.pop()
    }
    return (word === rword)
}

function isPlalindrome0 (word) {
    let tempArr = word.split('')
    return (tempArr.join('') === tempArr.reverse().join(''))
}

```
3. 冒泡排序
```js
function bubbleSort (arr) {
    arr.forEach((item, index) => {
        for (let i = 0; i < arr.length - index; i ++) {
            if (arr[i] > arr[i + 1]) {
                // 使用结构赋值 实现两个变量互换
                [ arr[i], arr[i+1] ] = [ arr[i + 1], arr[i] ]
            }
        }
    })
    console.log(arr)
}
bubbleSort([1,4,2,6])
```
4. 快速排序: 快排就是一开始找个中介，然后把比它小的放左边，比它大的放右边，然后重新对中介两边的数据各自重新找个中介,如此循环。
```js
function quickSort (arr) {
    if (arr.length <= 1) return arr // 递归的结束条件
    
    let pivotIndex = Math.floor(arr.length / 2)
    let pivot = arr.splice(pivotIndex, 1)[0] // 在数组中取出中间值
    let left = []
    let right = []
    arr.forEach (item => {
        if (item < pivot) {
            left.push(item)
        } else {
            right.push(item)
        }
    })
    return quickSort(left).concat(pivot, quickSort(right))
}

bubbleSort([1,4,2,100,4,6,7])
```
5. 选择排序: 找到数组中最小的那个元素，将它和数组的第一个元素交换位置; 在剩下的数组中找到最小的元素，将它和数组的第二个元素交换; .....
```js
function selectSort (arr) {
    arr.forEach((item, index) => {
        let min = arr[index]
        for(let i = 1; i < arr.length; i ++) {
            if (min > arr[i]) {
                min = arr[i]
            }
        }
        arr[index] = min
    })
    return arr
}
console.log(quickSort([1,4,900,2,100,4,6,7]))
```
6. 插入排序: 
