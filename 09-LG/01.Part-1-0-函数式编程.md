// 需要回顾补充笔记的 
- 08. 常用的高阶函数
- 13. 纯函数的好处
- 17. 柯里化案例
## 为什么要函数式编程
- React 就是
- vue 3 使用
- 可以抛弃 this
- 打包过程可以更好的利用 tree shaking 过滤无用的代码
- 方便测试 方便并行处理
- 有很多库可以帮助我们进行函数式编程 : lodash underscore ramda

## 概念
- Functional Programming , FP 是编程范式(面向过程, 面向对象)之一
- 用来描述数据之间的映射
```js
// 非函数式编程(面向过程)
let num1 = 1
let num2 = 2
let sum = num1 + num2 
console.log(sum)

// 函数式编程
function add (n1, n2) {
    return n1 + n2
}
let sum = add (1, 2)
console.log(sum)
```
- 函数式一等公民
    - 函数可以存储在变量中(数组中也可以)
    - 函数可以作为参数(就是高阶函数) Higher-order-function
    - 函数可以作为返回值(也是高阶函数)

### 高阶函数
- 函数作为参数
```js
// 模拟forEach 
function (arr, fn) {
    for (let i = 0; i < arr.length; i++>) {
        fn(arr[i])
    }
}
// 模拟 filter
function (arr, fn) {
    let results = []
    for (let i = 0; i< arr.lentht; i++) {
        if (fn(arr[i])) {
            res.push(arr[i])
        }
    }
    return results
}
```
- 函数作为返回值
```js
// 高阶函数作为返回值

// 基本语法
function makeFn () {
    let msg = "hello world"
    return function () {
        console.log(msg)
    }
}

// 调用
makeFn()()   // hello world

// 实现 once 函数 就是轮播图里的 锁 lodash中的 once 函数 
// 使用场景 支付 

function once (fn) {
    let done = false
    return function () {
        if (!done) {
            done = true
            fn(...arguments)
        }
    }
}

let pay = once(function(money){
    console.log(money)
})
pay(4)   // 4 // 只会执行一次
pay(4)   // 核心代码不执行
```
- 常用的高阶函数 
    - forEach map filter every some find/findIndex reduce sort ....
- 高阶函数的意义
    - 让代码更灵活
    - 实际是对通用性的一些抽象 让我们只关注自己逻辑
    - 使代码更简洁
- 常用的高阶函数
----------------------------------------------------------------------------------------08

### 闭包
- 概念 在一个函数1中定义一个变量2和函数3 在3总引用了2  就形成了闭包
```
function makeFn () {
    let msg = "hello world"
    return function () {
        console.log(msg)
    }
}
```
- 意义
    - 延长了 函数的作用范围(使用的本函数外部的变量)
    - 做的了缓存  比如上边的 once 函数 就缓存了 done 这个变量
- 本质
    - 函数在执行的时候 会放在一个执行栈上 当函数执行完毕就会从执行栈上移除
    - 但是 堆上的作用域成员(done 这个变量) 因为被外部引用不能被释放, 因此 内部函数依然可以访问外部函数的成员(done)

### 纯函数

- 概念: 相同的输入永远会得到相同的输出
- 举例
    - lodash 是一个纯函数的功能库
    - 数组的 slice(纯函数) splice(非纯函数 因为他改变了原数组 导出 多次相同的输入得到不同输出)
- 好处

----------------------------------------------------------------------------------------13

- 副作用
    - 当一个纯函数 依赖外部变量(配置文件, 数据库, 获取用户的输入)时 就会变得不纯
    - 所有的外部交互都可能带来副作用 副作用是方法的通用性下降 带来安全隐患
    - 不能完全禁止 尽量控制他们在可控范围内发生

# 函数柯里化 (curry)
- 当一个函数有多个参数的时候先传递一部分参数调用它(传进去的参数以后永远不变)
- 然后返回一个新的函数接收剩余参数 返回结果
> 简单理解 一个函数有两个参数  一个参数总是固定的 另一个不固定  此时可以 封一个新函数 return 出 只有一个变量的函数  就是函数柯里化
```js
// 简单的柯里化
// 场景
function checkAge(min, age) {
    return age >= min
}
console.log(checkAge(18, 22)) // true
console.log(checkAge(18, 30)) // true
console.log(checkAge(18, 16)) // false
// 函数柯里化改造
function checkAgeCurry (min) {
    return function (age) {
        return age >= age
    }
}
let checkAge18 = checkAgeCurry(18)
console.log(checkAge18(20)) // true

```
> lodash 中的 curry 使用
```js
const _ = require('lodash')
function getSum (a, b, c) {
    return a + b + c
} 
const curried = _.curry(getSum)
console.log(curried(1,2,3)) // 6 此时其实没有意义
console.log(curried(1,2)(3))
console.log(curried(1)(2,3))
```
> 柯里化案例
```js
-----------------------------------------------------------------17
```

> 模拟 lodash 中的 curry 方法
```js
function curry (fn) {
    return function curriedFn(...args) {
        if (args.length < fn.length) {
            return function () {
                return curriedFn(...[...args, ...Array.from(arguments)])
                // return curriedFn(...args.concat(Array.from(arguments)))
            }
        }
        return fn(...args)
    }
}

function getSum (a, b, c) {
    // console.log(getSum.length, 10)
    return a + b + c
} 
const curried = curry(getSum)
console.log(curried(1,2,3)) // 6 此时其实没有意义
console.log(curried(1,2)(3))
console.log(curried(1)(2,3))
```
- 总结
    - 柯里化可以让我们给一个函数传递较少的参数得到一个记住某些固定参数的新函数
    - 其实 柯里化就会使用了闭包
    - 这是对 函数参数 的'缓存'
    - 然函数更灵活 让函数的颗粒度更小
    - 可以吧多元函数转换成一元函数 可以组合使用函数产生更强大的功能

### 函数组合概念
```js
// 函数组合演示 有了first 函数 有了 reverse 函数  就可以组合出 last 功能函数
function compose (f, g) {
    return function (val) {
        return f(g(val))
    }
}

function reverse (arr) {
    return arr.reverse()
}

function first (arr) {
    return arr[0]
}

const last = compose(first, reverse)
console.log(last([1,2,3,4,5]))

```
- 函数组合要满足结合律
```
let f = compose(f, g, h)
let associative = compose(compose(f, g), h) == compose(f, compose(g, h)) // true
```

- 组合函数的调试 可以定义一个 log 函数放进去 注意log函数的位置
```
const  _ = require('lodash')

const log = v => {
    console.log(v)
    return v
}

function reverse (arr) {
    return arr.reverse()
}

function first (arr) {
    return arr[0]
}

const last = _.flowRight(first, log, reverse)
console.log(last([1,2,3,4,5]))
// [ 5, 4, 3, 2, 1 ]  // 这个就 log函数打印的结果  是 reverse 函数处理后输出的结果
// 5
```

### PointFree  风格模式  就是函数的组合
```js
// point free 模式 实现  'Hello    World' -> 'hello_world'
const  fp = require('lodash/fp')

const f = fp.flowRight(fp.replace(/\s+/g, '-'), fp.toUpper)
console.log(f('Hello    World'))
```


### Functor(函子)

概念: 
- 可以理解为一个盒子  自己不会去改变  想改变 就用它提供的 map 方法 传递回调
- 回调处理后 又返回一个新的函子  就可以实现链式编程  无限的调用

```js
// 一般实现
class Container {
    constructor (val) {
        this._val = val
    }
    map (fn) {
        return new Container(fn(this._val))
    }
}
let r = new Container(5)
    .map(item => item + 1)
    .map(item => item + 1)
    .map(item => item + 1)

console.log(r) // { _val: 8 }

// 新实现
class Container {
    static of (val) {
        return new Container(val)
    }
    constructor (val) {
        this._val = val
    }
    map (fn) {
        return Container.of(fn(this._val))
    }
}
let r = new Container(5)
    .map(item => item + 1)
    .map(item => item + 1)
    .map(item => item + 1)

console.log(r) // { _val: 8 }
```











