# ECMAScript 新特性

## 概念和背景
- JavaScript 语言本身指的就是 ECMAScript
- 2015年开始每年就有一个版本迭代
    - 2015年的就是(ES2015)  ES6  很多颠覆式的新功能
    - 现在的很多资料中都以 ES6 泛指 2015年以后的所有新特性
- 解决原有语法的问题和不足
- 对原有语法的增强
- 全新的对象 全新的方法 全新的功能
- 全新的数据类型和数据结构

## let const
-   作用域分为全局作用域 函数作用域 块级作用域(新增)

## Array 的机解构赋值
```js
const arr = [100, 200, 300]
const [ , , bar] = arr
const [foo, ...rest] = arr  // 获取剩余变量
const [a, b, c, d] = arr
const [e = '没用', f, g, h = 996] = arr // 给解构不到的设置默认值
console.log(bar)  //300
console.log(rest) // [200, 300]
console.log(d)    // undefined
console.log(e)    // 100 解构到值了 默认值就不生效了
console.log(h)    // 996

const path = '/a/b/c'
const [,rootdir] = path.split('/')
console.log(rootdir) // a
```

## Object 的解构赋值
```js
const obj = {name: '小明', age: 18}
const { age } = obj
const name = '小红'
const {name:objName} = obj // 给解构的值 设置别名
const {name:objName0 = '默认名字'} = obj // 此时还是可以用 = 设置默认值
console.log(age)
console.log(objName)
console.log(objName0)
```

## 模板字符串 ``
- 模板中可以使用 js 语句
```js
// 插值语法中 可以是变量 可以是 js 语句
const str = `hello es2015, this is a string ${1+ 1} ${Math.random()}`
const {log} = console
log(str) // [ 'hey, ', ' is a ', '' ]
```
- 模板中可以使用标签函数实现特殊加工处理
```js

const name = 'Tom'
const gender = true

function myTagFunc (string, name, gender) {
    // console.log(string, name, gender)
    const sex = gender? 'man' : 'woman' 
    return string[0] + name + string[1] + sex + string[2]
}
const result = myTagFunc`hey, ${name} is a ${gender}` // [ 'hey, ', ' is a ', '' ] Tom true
console.log(result)

// 总结: 
//   - 可以使用标签函数的特性实现文本的多语
//   - 可以检查模板中是否存在不安全的字符
//   - 还可以现实一个简版的模板引擎
```

### 字符串的拓展

- console.log('abc'.startsWith('a'))  // true
- console.log('abc'.endsWith('a'))    // false
- console.log('abc'.includes('b'))    // true

### 参数默认值

- 一般情况 使用默认值 在函子体中写逻辑 判断
    - 习惯使用 || 实际是不对的 如果 参数为 false  也会使用默认值
    - 其实应该 使用 aa === undefined 作为判断条件
```js
function foo(abc) {
    if (abc === undefined) {
        abc = '123'
    }
    console.log(abc)
}
foo()    // 123
foo(999) // 999
```

- 有了es6 就方便很多了
```js
// 但是要注意 有默认值的参数一定要放在最后
function(bar, c, b = true)
```

### 函数剩余参数
```js
function (a, ...rest) {
    console.log(rest)
}

// rest 就是剩余的参数  
// 只能放最后  
//只能使用一次

```

### 展开运算
```js
const arr = [1,2,3]
console.log(arr[0], arr[1], arr[2])
console.log.apply(console, arr)
console.log(...arr)

```

### 箭头函数

- 代码简化很多

### 箭头函数的 this
- 箭头函数中不会改变 this 的指向

### 对象字面量的增强

- 属性的简写
- 函数的省略写法
- 动态 key

```js
const bar = '123'

const obj = {
    bar,     // 同名的可以简写
    ddd: 1232,
    [1+ 1]: 12,  // 可以使用动态的key  用 [] 包裹一下就可以了
    [Math.random()]: 9, 
    fn () {  // 就是普通的函数  可以使用 this 
        console.log(this.bar) 
    }
}
console.log(obj)
obj.fn()  // 123
```

### Proxy


### Reflect 内部封装了一系列对对象底层的操作
- 意义
    - 统一提供了一套用于操作对象的API(13个方法 官方建议多食用)
```js
const obj = {
    name: '小明',
    age: 18,
    gender: true,
}
// 实现 验证 删除 获取keys 很不统一
// console.log( 'name' in obj)
// console.log( delete obj.age)
// console.log( Object.keys(obj))

// 使用 Reflect 就很统一 很整洁
console.log(Reflect.has(obj, 'name'))
console.log(Reflect.deleteProperty(obj, 'age'))
console.log(Reflect.ownKeys(obj))
 
```

### Promise 对象

### class 类 
```js
class Person {
    constructor (name) {
        this.name = name
    }
    say () {
        console.log(`Hi, my name is ${this.name}`)
    }
}

class Student extends Person {
    constructor (name, number) {
        super(name) // 因为父类需要传参  就要调用 super 传递参数
        this.number = number
    }
    hello () {
        super.say()  // 如果想调取 父类的方法  可以用 super . 出来
        console.log(`My school number is ${this.number}`)
    }
}

const s = new Student('小明', '大学')
s.hello()
```



  











